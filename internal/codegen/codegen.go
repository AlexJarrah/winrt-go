package codegen

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-kit/log"
	"github.com/go-kit/log/level"
	"github.com/saltosystems/winrt-go/winmd"
	"github.com/tdakkota/win32metadata/md"
	"github.com/tdakkota/win32metadata/types"
)

type classNotFoundError struct {
	class string
}

func (e *classNotFoundError) Error() string {
	return fmt.Sprintf("class %s was not found", e.class)
}

type generator struct {
	logger log.Logger
}

// Generate generates the code for the given config.
func Generate(cfg *Config, logger log.Logger) error {
	if err := cfg.Validate(); err != nil {
		return err
	}

	g := &generator{
		logger: logger,
	}
	return g.run(cfg)
}

func (g *generator) run(cfg *Config) error {
	_ = level.Debug(g.logger).Log("msg", "starting code generation", "class", cfg.Class)

	fs, err := winmd.AllFiles()
	if err != nil {
		return err
	}

	// we don't know which winmd file contains the class, so we have to iterate over all of them
	for _, f := range fs {
		i, err := g.findClass(f.Name(), cfg.Class)
		if err != nil {
			// class not found errors are ok
			if _, ok := err.(*classNotFoundError); ok {
				continue
			}

			return err
		}

		return g.generateClass(f.Name(), cfg.Class, i)
	}

	return fmt.Errorf("class %s was not found", cfg.Class)

}

func (g *generator) findClass(path, class string) (uint32, error) {
	c, err := parseWinMDFile(path)
	if err != nil {
		return 0, err
	}

	tt := c.Table(md.TypeDef)
	for i := uint32(0); i < tt.RowCount(); i++ {
		var t types.TypeDef
		if err := t.FromRow(tt.Row(i)); err != nil {
			return 0, err
		}

		if t.TypeNamespace+"."+t.TypeName == class {
			return i, nil
		}
	}
	return 0, &classNotFoundError{class: class}
}

func (g *generator) generateClass(path, class string, i uint32) error {
	c, err := parseWinMDFile(path)
	if err != nil {
		return err
	}

	// get type from typeDef table
	var t types.TypeDef
	tt := c.Table(md.TypeDef)
	if err := t.FromRow(tt.Row(i)); err != nil {
		return err
	}

	// we only support runtime classes: check the tdWindowsRuntime flag (0x4000)
	if t.Flags&0x4000 == 0 {
		return fmt.Errorf("%s.%s is not a runtime class", t.TypeNamespace, t.TypeName)
	}

	_ = level.Info(g.logger).Log("msg", "generating class from file", "class", class, "file", path)

	// get templates
	tmpl, err := getTemplates()
	if err != nil {
		return err
	}

	// execute templates
	var buf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buf, "file.tmpl", getGenData(c, t)); err != nil {
		return err
	}

	// create file & write contents
	filename := strings.ToLower(t.TypeName)
	file, err := os.Create(filepath.Clean(filename + ".go"))
	if err != nil {
		return err
	}
	defer func() { _ = file.Close() }()
	_, err = file.Write(buf.Bytes())
	return err
}

func parseWinMDFile(path string) (*types.Context, error) {
	f, err := winmd.Open(path)
	if err != nil {
		return nil, err
	}
	defer func() { _ = f.Close() }()

	return types.FromPE(f)
}

func getGenData(c *types.Context, t types.TypeDef) *genData {
	return &genData{
		Imports: []genImport{
			// this should be autogenerated from the used types but
			//  we will keep it this ways because it is still very simple
			{Name: "syscall"},
			{Name: "unsafe"},
			{Name: "github.com/go-ole/go-ole"},
		},
		Types: []genType{}, //TODO
		Funcs: []genFunc{}, //TODO
	}
}
