package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-kit/log"
	"github.com/go-kit/log/level"
	"github.com/saltosystems/winrt-go/winmd"
	"github.com/tdakkota/win32metadata/md"
	"github.com/tdakkota/win32metadata/types"
)

type classNotFoundError struct {
	class string
}

func (e *classNotFoundError) Error() string {
	return fmt.Sprintf("class %s was not found", e.class)
}

type generator struct {
	logger log.Logger
}

// Generate generates the code for the given config.
func Generate(cfg *Config, logger log.Logger) error {
	if err := cfg.Validate(); err != nil {
		return err
	}

	g := &generator{
		logger: logger,
	}
	return g.run(cfg)
}

func (g *generator) run(cfg *Config) error {
	_ = level.Debug(g.logger).Log("msg", "starting code generation", "class", cfg.Class)

	fs, err := winmd.AllFiles()
	if err != nil {
		return err
	}

	// we don't know which winmd file contains the class, so we have to iterate over all of them
	for _, f := range fs {
		i, err := g.findClass(f.Name(), cfg.Class)
		if err != nil {
			// class not found errors are ok
			if _, ok := err.(*classNotFoundError); ok {
				continue
			}

			return err
		}

		return g.generateClass(f.Name(), cfg.Class, i)
	}

	return fmt.Errorf("class %s was not found", cfg.Class)

}

func (g *generator) findClass(path, class string) (uint32, error) {
	c, err := parseWinMDFile(path)
	if err != nil {
		return 0, err
	}

	tt := c.Table(md.TypeDef)
	for i := uint32(0); i < tt.RowCount(); i++ {
		var t types.TypeDef
		if err := t.FromRow(tt.Row(i)); err != nil {
			return 0, err
		}

		if t.TypeNamespace+"."+t.TypeName == class {
			return i, nil
		}
	}
	return 0, &classNotFoundError{class: class}
}

func (g *generator) generateClass(path, class string, i uint32) error {
	c, err := parseWinMDFile(path)
	if err != nil {
		return err
	}

	// get type from typeDef table
	var t types.TypeDef
	tt := c.Table(md.TypeDef)
	if err := t.FromRow(tt.Row(i)); err != nil {
		return err
	}

	// we only support runtime classes: check the tdWindowsRuntime flag (0x4000)
	if t.Flags&0x4000 == 0 {
		return fmt.Errorf("%s.%s is not a runtime class", t.TypeNamespace, t.TypeName)
	}

	_ = level.Info(g.logger).Log("msg", "generating class from file", "class", class, "file", path)

	// get templates
	tmpl, err := getTemplates()
	if err != nil {
		return err
	}

	// get data & execute templates
	data, err := getGenData(c, t)
	if err != nil {
		return err
	}
	var buf bytes.Buffer
	if err := tmpl.ExecuteTemplate(&buf, "file.tmpl", data); err != nil {
		return err
	}

	// create file & write contents
	filename := strings.ToLower(t.TypeName)
	file, err := os.Create(filepath.Clean(filename + ".go"))
	if err != nil {
		return err
	}
	defer func() { _ = file.Close() }()

	// format the output source code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	// and write it to file
	_, err = file.Write(formatted)

	return err
}

func parseWinMDFile(path string) (*types.Context, error) {
	f, err := winmd.Open(path)
	if err != nil {
		return nil, err
	}
	defer func() { _ = f.Close() }()

	return types.FromPE(f)
}

func getGenData(c *types.Context, t types.TypeDef) (*genData, error) {
	types, err := getGenTypes(c, t)
	if err != nil {
		return nil, err
	}

	return &genData{
		Imports: []genImport{
			// this should be autogenerated from the used types but
			//  we will keep it this ways because it is still very simple
			{Name: "syscall"},
			{Name: "unsafe"},
			{Name: "github.com/go-ole/go-ole"},
		},
		Types: types,
		Funcs: []genFunc{}, //TODO
	}, nil
}

func getGenTypes(c *types.Context, t types.TypeDef) ([]genType, error) {
	gentypes := []genType{}

	// class interface
	gentypes = append(gentypes, genType{
		Name: "I" + t.TypeName + "",
		EmbeddedStructs: []qualifiedID{
			{
				Package: "ole",
				Name:    "IInspectable",
			},
		},
	})

	// class vtable interface
	methods, err := getMethods(c, t)
	if err != nil {
		return gentypes, nil
	}
	gentypes = append(gentypes, genType{
		Name: "I" + t.TypeName + "Vtbl",
		EmbeddedStructs: []qualifiedID{
			{
				Package: "ole",
				Name:    "IInspectableVtbl",
			},
		},
		Methods: methods,
	})
	return gentypes, nil
}

func getMethods(c *types.Context, t types.TypeDef) ([]genMethod, error) {
	methods, err := t.ResolveMethodList(c)
	if err != nil {
		return nil, err
	}

	var genMethods []genMethod
	for _, m := range methods {
		genMethods = append(genMethods, genMethod{
			Name:     m.Name,
			IsStatic: m.Flags.Static(),
		})
	}

	return genMethods, nil
}
