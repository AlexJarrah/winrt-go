
const GUID{{.Name}} string = "{{.GUID}}"
const Signature{{.Name}} string = "{{.Signature}}"

type {{.Name}} struct {
	ole.IUnknown
	sync.Mutex
	refs uint64
	IID  ole.GUID
}

type {{.Name}}Vtbl struct {
	ole.IUnknownVtbl
	Invoke uintptr
}

type {{.Name}}Callback func(instance *{{.Name}},{{- range .InParams -}}
	{{.GoVarName}} {{template "variabletype.tmpl" . }},
{{- end -}})

var callbacks{{.Name}} = &{{.Name | toLower}}CallbacksMap {
	mu:        &sync.Mutex{},
	callbacks: make(map[unsafe.Pointer]{{.Name}}Callback),
}

func New{{.Name}}(iid *ole.GUID, callback {{.Name}}Callback) *{{.Name}} {
	size := unsafe.Sizeof(*(*{{.Name}})(nil))
	instPtr := kernel32.Malloc(size)
	inst := (*{{.Name}})(instPtr)
	// Initialize all properties: the malloc may contain garbage
	inst.RawVTable = (*interface{})(unsafe.Pointer(&{{.Name}}Vtbl{
		IUnknownVtbl: ole.IUnknownVtbl{
			QueryInterface: syscall.NewCallback(inst.QueryInterface),
			AddRef:         syscall.NewCallback(inst.AddRef),
			Release:        syscall.NewCallback(inst.Release),
		},
		Invoke: syscall.NewCallback(inst.Invoke),
	}))
	inst.IID = *iid // copy contents
	inst.Mutex = sync.Mutex{}
	inst.refs = 0

	callbacks{{.Name}}.add(unsafe.Pointer(inst), callback)

	inst.addRef()
	return inst
}

// addRef increments the reference counter by one
func (r *{{.Name}}) addRef() uint64 {
	r.Lock()
	defer r.Unlock()
	r.refs++
	return r.refs
}

// removeRef decrements the reference counter by one. If it was already zero, it will just return zero.
func (r *{{.Name}}) removeRef() uint64 {
	r.Lock()
	defer r.Unlock()

	if r.refs > 0 {
		r.refs--
	}

	return r.refs
}

func (instance *{{.Name}}) QueryInterface(_, iidPtr unsafe.Pointer, ppvObject *unsafe.Pointer) uintptr {
	// Checkout these sources for more information about the QueryInterface method.
	//   - https://docs.microsoft.com/en-us/cpp/atl/queryinterface
	//   - https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)

	if ppvObject == nil {
		// If ppvObject (the address) is nullptr, then this method returns E_POINTER.
		return ole.E_POINTER
	}

	// This function must adhere to the QueryInterface defined here:
	// https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown
	iid := (*ole.GUID)(iidPtr)
	if ole.IsEqualGUID(iid, &instance.IID) || ole.IsEqualGUID(iid, ole.IID_IUnknown) || ole.IsEqualGUID(iid, ole.IID_IInspectable){
		*ppvObject = unsafe.Pointer(instance)
	} else {
		*ppvObject = nil
		// Return E_NOINTERFACE if the interface is not supported
		return ole.E_NOINTERFACE
	}

	// If the COM object implements the interface, then it returns
	// a pointer to that interface after calling IUnknown::AddRef on it.
	(*ole.IUnknown)(*ppvObject).AddRef()

	// Return S_OK if the interface is supported
	return ole.S_OK
}

func (instance *{{.Name}}) Invoke(instancePtr unsafe.Pointer {{range .InParams -}}
			,
			{{- if .Type.IsEnum -}}
					{{.GoVarName}}Raw {{.Type.UnderlyingEnumType}}
			{{- else -}}
					{{.GoVarName}}Ptr unsafe.Pointer
			{{- end}}
	{{- end -}}) uintptr {
	// See the quote above.
	{{range .InParams -}}
			{{if .Type.IsEnum -}}
					{{.GoVarName}} := ({{template "variabletype.tmpl" . }})({{.GoVarName}}Raw)
			{{else -}}
					{{.GoVarName}} := ({{template "variabletype.tmpl" . }})({{.GoVarName}}Ptr)
			{{end -}}
	{{end -}}
	if callback, ok := callbacks{{.Name}}.get(instancePtr); ok {
		callback(instance, {{range .InParams}}{{.GoVarName}},{{end}})
	}
	return ole.S_OK
}

func (instance *{{.Name}}) AddRef() uint64 {
	return instance.addRef()
}

func (instance *{{.Name}}) Release() uint64 {
	rem := instance.removeRef()
	if rem == 0 {
		// We're done.
		instancePtr := unsafe.Pointer(instance)
		callbacks{{.Name}}.delete(instancePtr)
		kernel32.Free(instancePtr)
	}
	return rem
}

type {{.Name | toLower}}CallbacksMap struct {
	mu        *sync.Mutex
	callbacks map[unsafe.Pointer]{{.Name}}Callback
}

func (m *{{.Name | toLower}}CallbacksMap) add(p unsafe.Pointer, v {{.Name}}Callback) {
	m.mu.Lock()
	defer m.mu.Unlock()

	m.callbacks[p] = v
}

func (m *{{.Name | toLower}}CallbacksMap) get(p unsafe.Pointer) ({{.Name}}Callback, bool) {
	m.mu.Lock()
	defer m.mu.Unlock()

	v, ok := m.callbacks[p]
	return v, ok
}

func (m *{{.Name | toLower}}CallbacksMap) delete(p unsafe.Pointer) {
	m.mu.Lock()
	defer m.mu.Unlock()

	delete(m.callbacks, p)
}
